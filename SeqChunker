#!/bin/bash

##----------------------------------------------------------------------------##
# Author: Thomas Hackl, thomas.hackl@uni-wuerzburg.de
# Last Modified: Thomas Hackl, 2013-08-20
# Version 0.12


##----------------------------------------------------------------------------##
## CHANGELOG

## 0.12
# removed chunk-ratio
# reverted to integer arithmetics
# autocompute chunk number

## 0.11
# CHUNK_STEP: experimental
# LC_ALL instead of LC_NUMERIC

## 0.10
# initial script


##----------------------------------------------------------------------------##
## TODO
# stdin

##----------------------------------------------------------------------------##
# Variable defaults
DEBUG=1;
CHUNK_NUM=0;
CHUNK_SIZE=0;
CHUNK_SKIP=0;
CHUNK_COUNT=0;
CHUNK_RATIO=1;
SKIP=0;
OUT="";
SPLIT=0;
MAX_BLOCK_SIZE=1000000;

SED_FIRST_FASTA='/^>/{p;q}';
SED_LAST_FASTA='/^>/q'; # last line needs to go to cache

SED_FIRST_FASTQ='/^@/ { # if ^@
                N # read a second line
                /\n@/ { s/^@.*\n// ; N} # remove first line and read another
                N;N;p;q; # read two more lines, print and quit
        }'
        
SED_LAST_FASTQ='/^@/ { # if ^@
                N # read a second line
                /\n@/ { N } # read additonal line if second is head
                N;N;q; # read two more lines, print and quit
        }'

show_usage()
{
  echo "Usage: SeqChunker --chunk-number/--chunk-size INT [OPTIONS ...] FILE1 FILE2 ..."
}

show_help()
{
  show_usage
  cat <<EOF

SeqChunker efficiently samples and outputs chunks from FASTA and FASTQ files, 
 e.g. to serve as on-the-fly input for other tools. 

  -n/--chunk-number       Number of chunks to be sampled.
  -s/--chunk-size         Size of chunks to be sampled.
  
NOTE: Either one of the above is required, but both are not allowed. The 
 other parameter is computed respectively.
  
  -k/--chunk-skip         Skip this many chunks in output [$CHUNK_SKIP]
  -c/--chunk-count        Stop outputting after this many outputted chunks. 0 means all [$CHUNK_COUNT] 
  -o/--out                Output filename. To split chunks into single files provide a
                          "printf" pattern, e.g. "chunk%02d.fa", with a substitution for 
                          the chunk counter.
  -m/--max-block-size     Maximum size of blocks in output stream [$MAX_BLOCK_SIZE]
  -q/--quiet              Suppress non-critical messages
  -d/--debug              Output more verbose messages
  -h/--help               Show this help screen

NOTE: Chunk related computations are run each input file individually.

NOTE: Do not use chunk sizes similar to or smaller than the expected record 
 sizes. Heuristics get messed up and cause unpredictable behaviour.

EOF
}

# Execute getopt
ARGS=`getopt --name "SeqChunker" \
    --options "n:s:k:c:r:b:m:o:qdh" \
    --longoptions "chunk-number:,chunk-size:,chunk-count:,chunk-skip:,chunk-ratio:,byte-skip:,out:,quiet,debug,help" \
    -- "$@"`

#Bad arguments
[ $? -ne 0 ] && exit 1;

# A little magic
eval set -- "$ARGS"

# Now go through all the options
while true; do
    case "$1" in
        -n|--chunk-number)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            if [[ "$2" =~ [^0-9] ]]; then
                echo "$1: '$2' not an INT" 1>&2;
                exit 1;
            fi;
            CHUNK_NUM=$2;
            shift 2;;

        -s|--chunk-size)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            if [[ "$2" =~ [^0-9] ]]; then
                echo "$1: '$2' not an INT" 1>&2;
                exit 1;
            fi;
            CHUNK_SIZE=$2
            shift 2;;

        -k|--chunk-skip)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            if [[ "$2" =~ [^0-9~] ]] ; then
                echo "$1: '$2' not a valid input" 1>&2;
                exit 1;
            fi;
            if [[ "$2" =~ ~ ]]; then 
	            CHUNK_SKIP=${2%%~*};
	            CHUNK_STEP=${2##*~};
            else
                CHUNK_SKIP=$2;
                CHUNK_STEP=1;
            fi;
            shift 2;;

        -c|--chunk-count)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            if [[ "$2" =~ [^0-9] ]]; then
                echo "$1: '$2' not an INT" 1>&2;
                exit 1;
            fi;
            CHUNK_COUNT=$2
            shift 2;;

        -o|--out)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            OUT=$2
            shift 2;;
            	     
        -m|--max-block-size)
            [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            if [[ "$2" =~ [^0-9] ]]; then
                echo "$1: '$2' not an INT" 1>&2;
                exit 1;
            fi;
            MAX_BLOCK_SIZE=$2
            shift 2;;

        -q|--quiet)
           DEBUG=0
           shift;;

        -d|--debug)
           DEBUG=2
           shift;;
           	    	        	        
	    -h|--help)
	       show_help && exit 0;;
	       
        --)
            shift
            break;;
        *)
            echo "$1: Unknown option" 1>&2 && exit 1;;
  esac
done

        # -b|--byte-skip)
            #    [ ! -n "$2" ] && (echo "$1: value required" 1>&2 && exit 1);
            #if [[ "$2" =~ [^0-9] ]]; then
                #    echo "$1: '$2' not an INT" 1>&2;
                #exit 1;
            #fi;
            #SKIP=$2
            #shift 2;;

[ $DEBUG -gt 1 ] && echo "ARGS=$ARGS" 1>&2;

# process some args and opts
[ $# -eq 0 ] && (echo "FILE required" 1>&2 && show_usage && exit 1)

if [ $CHUNK_SIZE -gt 0 ] && [ $CHUNK_NUM -gt 0 ]; then
    echo "Either --chunk-size or --chunk-number required, not both" 1>&2
    show_usage
    exit 1
fi;

if [ $CHUNK_SIZE -eq 0 ] && [ $CHUNK_NUM -eq 0 ]; then
    echo "Either --chunk-size or --chunk-number required, not both" 1>&2
    show_usage
    exit 1
fi;


# process files
for FILE in $@; do
    
    FILE_SIZE=$( stat -L -c %s $FILE)
    [ $? -ne 0 ] && exit 1;
    [ $DEBUG -gt 1 ] && echo "FILE_SIZE=$FILE_SIZE" 1>&2;

    # FASTA/FASTQ
    IS_FASTQ=$(head -c 1 "$FILE" | sed 's/[^>@]/\!/;s/>/0/;s/@/1/;s/\n//'); 
    if [ "$IS_FASTQ" = "!" ]; then
        echo "FILE neither FASTA nor FASTQ" 1>&2 
        exit 1
    fi;

    # auto-compute 
    # chunk-size
	if [ $CHUNK_SIZE -eq 0 ]; then
		CHUNK_SIZE=$(( $FILE_SIZE/$CHUNK_NUM +1 ));
	else
	    CHUNK_NUM=$(( $FILE_SIZE/$CHUNK_SIZE +1 )); # better safe, lasts on eof anyway
	fi;
    
    [ $CHUNK_COUNT -eq 0 ] && CHUNK_COUNT=$(( $CHUNK_NUM-$CHUNK_SKIP ))
	
	[ $DEBUG -gt 1 ] && (
		echo CHUNK_SIZE=$CHUNK_SIZE 1>&2;
    )
	
	REC_CACHE="";
	CHUNK_SIZE_ADJUST=0;
	
	(
       	
        # CHUNK OUTPUT
        for I in $(seq $(( -$CHUNK_SKIP )) $(( $CHUNK_COUNT - 1 )) ); do
			if [ $DEBUG -gt 1 ]; then
			    [ $I -ge 0 ] && echo "CHUNK="$I 1>&2;
			    [ $I -lt 0 ] && echo "SKIPPED_CHUNK="$I 1>&2;
			fi;
			
			if [ $I -ge 0 ] && [ ! -z "$OUT" ]; then
                if [[ $OUT =~ % ]]; then
                    OUT_CHUNK=$(printf $OUT $I);
			        eval "exec 3>$OUT_CHUNK";
			    else
			        eval "exec 3>$OUT";
			    fi;
			else
			    exec 3>&1;
			fi;
			
            # check cache
			if [ ! -z "$REC_CACHE" ]; then
            [ $DEBUG -gt 1 ] && echo "  cache:" ${#REC_CACHE} byte 1>&2;
			[ $I -ge 0 ] && echo "$REC_CACHE" 1>&3;
  
            else
				# first record
                # FASTA
                if [ $IS_FASTQ  -eq 0 ]; then
			   	    PRE_REC_TAIL_AND_FIRST_REC_HEAD=$(sed --unbuffered -n -e "$SED_FIRST_FASTA");
	                PRE_REC_TAIL="${PRE_REC_TAIL_AND_FIRST_REC_HEAD%>*}";
	                FIRST_REC_HEAD=">""${PRE_REC_TAIL_AND_FIRST_REC_HEAD##*>}";
	            # FASTQ
	            else
                    PRE_REC_TAIL_AND_FIRST_REC_HEAD=$(sed --unbuffered -n -e "$SED_FIRST_FASTQ");
                    PRE_REC_TAIL=$(echo "$PRE_REC_TAIL_AND_FIRST_REC_HEAD" | head -n -4);
                    FIRST_REC_HEAD=$(echo "$PRE_REC_TAIL_AND_FIRST_REC_HEAD" | tail -n 4);
                fi;
                
                # eof
                if [ -z "$PRE_REC_TAIL_AND_FIRST_REC_HEAD" ]; then
                    # sometimes last chunk is empty -> remove
                    if [ -n "$OUT_CHUNK" ] && [ ! -s "$OUT_CHUNK" ]; then
                        $(rm "$OUT_CHUNK");
                    fi; 
                    break;
                else
                    [ $I -ge 0 ] && echo "$FIRST_REC_HEAD" 1>&3;
                fi;
                
                CHUNK_SIZE_ADJUST=$(( $CHUNK_SIZE_ADJUST + ${#PRE_REC_TAIL} ));
                if [ $DEBUG -gt 1 ]; then
                    echo "  pre record tail:" ${#PRE_REC_TAIL} byte 1>&2;
                    echo "  first record start:" ${#FIRST_REC_HEAD} byte 1>&2;
                fi;
			fi;
			
			# chunk core
            # adjust $CHUNK_SIZE for $CHUNK_SIZE_ADJUST
		    CHUNK_SIZE_REAL=$(( $CHUNK_SIZE - $CHUNK_SIZE_ADJUST ))
			[ $DEBUG -gt 1 ] && echo "  chunk content:" $CHUNK_SIZE_REAL byte 1>&2;
		    
			if [ $CHUNK_SIZE_REAL -gt $MAX_BLOCK_SIZE ]; then
		        BLOCK_COUNT=$(( $CHUNK_SIZE_REAL / $MAX_BLOCK_SIZE ))
		        BLOCK_REST=$(( $CHUNK_SIZE_REAL % $MAX_BLOCK_SIZE ))
			    [ $DEBUG -gt 1 ] && (
			        echo BLOCK_COUNT=$BLOCK_COUNT 1>&2;
			        echo BLOCK_REST=$BLOCK_REST 1>&2;
			    )
			    if [ $I -lt 0 ]; then
                    dd bs=$MAX_BLOCK_SIZE skip=$BLOCK_COUNT count=0 2>/dev/null;
                    dd bs=$BLOCK_REST skip=1 count=0 2>/dev/null;
			    else
					dd bs=$MAX_BLOCK_SIZE count=$BLOCK_COUNT 1>&3 2>/dev/null;
					dd bs=$BLOCK_REST count=1 1>&3 2>/dev/null;
                fi;
			elif [ $CHUNK_SIZE_REAL -gt 0 ]; then
				if [ $I -lt 0 ]; then
				    dd bs=$CHUNK_SIZE_REAL skip=1 count=0 2>/dev/null;
			    else
				    dd bs=$CHUNK_SIZE_REAL count=1 1>&3 2>/dev/null;
                fi;
			fi;
			
			# handle the final record of the chunk - needs to be complete
			# FASTQ
			if [ $IS_FASTQ -eq 0 ]; then
				# last record
				LAST_REC_TAIL_AND_POST_REC_HEAD=$(sed --unbuffered -e "$SED_LAST_FASTA");
				LAST_REC_TAIL=$(echo "$LAST_REC_TAIL_AND_POST_REC_HEAD" | head -n -1);
				LAST_REC_TAIL=${LAST_REC_TAIL%\\n} # chomp
	            [ $DEBUG -gt 1 ] && echo "  last record end:" ${#LAST_REC_TAIL} byte 1>&2;
				[ $I -ge 0 ] && echo "$LAST_REC_TAIL" 1>&3;
	    		REC_CACHE=$(echo "$LAST_REC_TAIL_AND_POST_REC_HEAD" | tail -n 1);
				CHUNK_SIZE_ADJUST=${#LAST_REC_TAIL_AND_POST_REC_HEAD}
			# FASTA
			else
                # last record
                LAST_REC_TAIL_AND_POST_REC_HEAD=$(sed --unbuffered -e "$SED_LAST_FASTQ");
                LAST_REC_TAIL=$(echo "$LAST_REC_TAIL_AND_POST_REC_HEAD" | head -n -4);
                LAST_REC_TAIL=${LAST_REC_TAIL%\\n} # chomp
                [ $DEBUG -gt 1 ] && echo "  last record end:" ${#LAST_REC_TAIL} byte 1>&2;
                [ $I -ge 0 ] && echo "$LAST_REC_TAIL" 1>&3;
                REC_CACHE=$(echo "$LAST_REC_TAIL_AND_POST_REC_HEAD" | tail -n 4);
                CHUNK_SIZE_ADJUST=${#LAST_REC_TAIL_AND_POST_REC_HEAD}
			fi;
		done;
	
	) < "$FILE";

done;


